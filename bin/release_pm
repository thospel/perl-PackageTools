#!/usr/bin/perl -w
# $HeadURL: http://prodbs1.bmsg.nl/repos/kpn/trunk/src/perl-modules/PackageTools/bin/release_pm $
# $Id: release_pm 2816 2008-01-28 09:08:42Z hospelt $
use strict;
use Getopt::Long;

our $VERSION = "1.006";

my $quot = qr/[\'\"]?/;
my $sums = "md5-versions";

Getopt::Long::Configure ("bundling");
my $start_digits  = 3;
my $start_version = 1;
die "Could not parse your command line. Try $0 -h\n" unless
    GetOptions("import-revision!"	=> \my $import_revision,
               "import-version!"	=> \my $import_version,
               "digits=i"		=> \$start_digits,
               "initial:s"		=> \my $start_release,
               "start_version=s",	=> \$start_version,
               "next"			=> \my $next,
	       "version!"		=> \my $print_version,
               "U|unsafe!"		=> \my $unsafe,
               "h|help!"		=> \my $help);

if ($print_version) {
    require PackageTools::Package;
    print <<"EOF";
release_pm $VERSION (PackageTools $PackageTools::Package::VERSION)
EOF
    exit 0;
}
if ($help) {
    require Config;
    $ENV{PATH} .= ":" unless $ENV{PATH} eq "";
    $ENV{PATH} = "$ENV{PATH}$Config::Config{'installscript'}";
    exec("perldoc", "-F", $unsafe ? "-U" : (), $0) || exit 1;
    # make parser happy
    %Config::Config = ();
}
die "Meaningless arguments\n" if @ARGV;
die "Cannot have both import-revision and import-version" if
    $import_revision && $import_version;

package PackageTools::Release;
use Carp;
use Digest::MD5 qw(md5_hex);
use Errno qw(ENOENT ESTALE);

our $history = <<'EOF'
use Carp;

sub released {
    my ($package, $version) = @_;
    my $p = $package;
    $p =~ s!::!/!g;
    my $history = $history{"lib/$p.pm"} ||
        croak "Could not find a history for package '$package'";
    my $lowest = 9**9**9;
    for my $v (keys %$history) {
        $lowest = $v if $v >= $version && $v < $lowest;
    }
    croak "No known version '$version' of package '$package'" if
        $lowest == 9**9**9;
    return $history->{$lowest};
}
EOF
    ;
# Import a complete file and return the contents as a single string
sub slurp {
    my ($file, $may_not_exist) = @_;
    croak "filename is undefined" if !defined $file;
    open(my $fh, "<", $file) or
        $may_not_exist && ($! == ENOENT || $! == ESTALE) ?
	return undef : croak "Could not open '$file': $!";
    # binmode $fh if $file =~ /\.(?:png|gif|jpg|jpeg)\z/i;
    binmode $fh if -B $file;
    my $rc = read($fh, my $slurp, 1024 + -s $fh);
    croak "File '$file' is still growing" if
        $rc &&= read($fh, $slurp, 1024, length $slurp);
    croak "Error reading from '$file': $!" if !defined $rc;
    close($fh) || croak "Error while closing '$file': $!";
    return $slurp;
}

sub spew {
    my $file = shift;
    croak "filename is undefined" if !defined $file;
    croak "We shouldn't be trying to update binary file '$file'" if -s $file && -B _;
    open(my $fh, ">", $file) || croak "Could not create '$file': $!";
    eval {
        print($fh @_) || croak "Error writing to '$file': $!";
        close($fh)    || croak "Error closing '$file': $!";
    };
    if ($@) {
        undef $fh;
        unlink($file) || die "Could not unlink '$file' after $@";
        die $@;
    }
}

sub get_versions_file {
    my ($class) = @_;
    my (%file_props, %released, $release, $begun, $ended, $digits);
    my $content = slurp($sums, 1);
    if (defined $content) {
        my $md5_versions_content = $content;
        my $line_nr;
        while ($md5_versions_content =~ s/^([^\n]*.)//s) {
            $line_nr++;
            my $line = $+;
            $line =~ s/\s+\z//;
            $line =~ s/^\s+//;
            next if $line eq "" || $line =~ /^\#/;
            if (!$begun) {
                if ($line =~ /^BEGIN\z/) {
                    $begun = 1;
                    next;
                }
                croak "Unexpected data before BEGIN at line $line_nr in file $sums";
            }
            croak "Unexpected data after END at line $line_nr in file $sums" if
                $ended;
            if ($line =~ /^VERSION\s+([a-fA-F\d]{32})\s+(\d+\.\d+)\s+(\S+)\z/) {
                croak "Duplicate VERSION entry for file $3\n" if
                    exists $file_props{$3};
                $file_props{$3} = {
                    old_chksum	=> $1,
                    version	=> $2,
                    file	=> $3,
                };
            } elsif ($line =~ /^RELEASED\s+(\d+\.\d+)\s+(\d+\.\d+)\s+(\S+)\z/) {
                croak "Duplicate RELEASED entry for file $3 version $1\n" if
                    exists $released{$3}{$1};
                $released{$3}{$1} = $2;
            } elsif ($line =~ /^RELEASE\s+(\d+\.\d+)\z/) {
                croak "Duplicate RELEASE\n" if defined $release;
                $release = $1;
            } elsif ($line =~ /^DIGITS\s+(\d+)\z/) {
                croak "Duplicate DIGITS\n" if defined $digits;
                $digits = $1;
            } elsif ($line =~ /^END\z/) {
                $ended = 1;
            } else {
                croak "Could not parse line $line_nr in file $sums";
            }
        }
    } else {
        $content = "";
    }

    $digits = $start_digits if !defined $digits;
    my $format = sprintf("%%.%df", $digits);
    if (!defined $release) {
        # croak "No RELEASE\n" if $content ne "";
        $start_release ||= 1;
        $release = sprintf($format, $start_release);
    }
    my $release_props = bless {
        step		=> 1/10**$digits,
        "format"	=> $format,
        start_version	=> sprintf($format, $start_version),
        digits		=> $digits,
        release		=> $release,
        release_changed	=> !$next,
        any_changes	=> 0,
        old_content	=> $content,
        old_file_props	=> \%file_props,
        released	=> \%released,
    }, $class;
    $release_props->next_release if $next;
    return $release_props;
}

sub next_version {
    my ($release_props, $version, $steps) = @_;
    Carp::confess "Assertion: No version" if !defined $version;
    $steps = 1 if !defined $steps;
    return sprintf($release_props->{format},
                   $version + $steps * $release_props->{step});
}

sub next_release {
    my ($release_props) = @_;
    if (!$release_props->{release_changed}) {
        $release_props->{release} = $release_props->next_version($release_props->{release});
        $release_props->{release_changed} = 1;
        print STDERR "Release $release_props->{release}\n";
    }
    $release_props->{any_changes} ||= 1;
}

sub chksum {
    my ($file_props) = @_;
    # Get rid of typical CVS/Subversion junk
    my $content = $file_props->{content};
    $content =~ s/\$(Revision|Date|Author|Id|URL|HeadURL):[^\n\$]+\$/\$$1: \$/g;
    return md5_hex($content);
}

sub get_MANIFEST {
    my $manifest = slurp("MANIFEST");
    if ($manifest !~ s/^\s*\Q$sums\E\s*\n//m) {
        croak "$sums is not in MANIFEST\n" if !defined $start_release;
        print STDERR "Creating empty $sums\n";
        spew($sums, "");
        print STDERR "Adding $sums to MANIFEST\n";
        spew("MANIFEST", "$manifest$sums\n");
    }
    # META.yml is often generated during the make dist so it's often absent
    # and even if it isn't versioning typically happens too late
    $manifest =~ s/^\s*META\.yml(?:[^\S\n]+.*|[^\S\n]*)\n//m;
    my @files = $manifest =~ /^\s*(\S+)/mg;
    my %seen;
    my $error;
    for my $file (@files) {
        $error .= "Duplicate in MANIFEST: $file\n" if $seen{lc $file}++;
    }
    die $error if $error;
    return @files;
}

sub get_files {
    my ($release_props) = @_;

    my $released = $release_props->{released};
    $release_props->{file_props} = \my %file_props;
    my @files = get_MANIFEST();
    $release_props->{files} = \@files;
    for my $file (@files) {
        my $file_props = delete $release_props->{old_file_props}{$file};
        if ($file_props) {
            $released->{$file}{$file_props->{version}} ||= do {
                print STDERR "Fixup missing RELEASED for $file\n";
                $release_props->{release};
            };
            $file_props->{version_changed} = !$next && $released->{$file}{$file_props->{version}} eq $release_props->{release};
        } else {
            $file_props = {
                version	=> $release_props->{start_version},
                version_changed => 1,
                file	=> $file,
            };
            $release_props->next_release;
            print STDERR "New $file\n";
        }
        $file_props->{content} = slurp($file);
        $file_props->{content_chksum} = $file_props->{disk_chksum} =
            chksum($file_props);
        if ($import_revision &&
            $file_props->{content} =~ /\$Revision\s*:\s*(\d+)\.(\d+)\S*\s*\$/) {
            $file_props->{version} = $release_props->next_version($1, $2);
            $file_props->{version_changed} = 1;
            $release_props->next_release;
        }
        if ($import_version &&
            $file_props->{content} =~ /^\s*(?:(?:my|our|BEGIN\s*\{)\s*)?\$VERSION\s*=\s*($quot)([\d._]+)\1\s*[;\}]/m) {
            $file_props->{version} = $release_props->next_version($2, 0);
            $file_props->{version_changed} = 1;
            $release_props->next_release;
        }
        $release_props->{released}{$file}{$file_props->{version}} ||= $release_props->{release} if $file_props->{version_changed} && $file ne $sums;
        $file_props{$file} = $file_props;
    }
    if (%{$release_props->{old_file_props}}) {
        $release_props->next_release;
        for my $file (keys %{$release_props->{old_file_props}}) {
            print STDERR "Forgetting $file\n";
        }
    }
    $release_props->{time_stamp} = time;
}

sub release {
    my ($release_props) = @_;
    my $file_props = $release_props->{file_props};
    my $changes;
    do {
        $changes = 0;
        for my $file (@{$release_props->{files}}) {
            my $file_props = $file_props->{$file} ||
                die "Assertion: Unknown file $file";;
            if ($file eq "README") {
                $file_props->{content} =~ s/^(.* version )(.*)\n/$1$release_props->{release}\n/i;
                $file_props->{content} =~ s/^(.*)\n=+\n/"$1\n" . "=" x length($1) . "\n"/ie;
            } elsif ($file eq "Changes") {
                if ($release_props->{any_changes}) {
                    my ($sec, $min, $hour, $mday, $mon, $year) =
                        gmtime($release_props->{time_stamp});
                    my $now = sprintf("%04d-%02d-%02d %02d:%02d:%02d UT",
                                      $year+1900, $mon+1, $mday,
                                      $hour, $min, $sec);
                    $file_props->{content} =~ s/^(Revision history for .*\s*\n|)([\d.]+)([^\S\n]*.*)/$1 . ($2 eq $release_props->{release} ? "$2\t$now" : "$release_props->{release}\t$now\n\n$2$3")/ie;
                }
            } elsif ($file eq "Package.pm" || $file =~ m!/Package.pm\z!) {
                no warnings "once";
                require Data::Dumper;
                require FindBin;
                local $Data::Dumper::Indent = 1;
                local $Data::Dumper::Sortkeys = 1;
                my $released_string =
                    Data::Dumper::Dumper($release_props->{released});
                $released_string =~ s/^\s*\$VAR1\s*=\s*{(.*)}\s*;\s*\z/use vars qw(\$VERSION %history);\n\$VERSION = "$release_props->{release}";\n%history = ($1);\n\n$history/s || die "Assertion: Unexpected Dumper output";
                $file_props->{content} =~ s/^[^\S\n]*\#\s*START\s+HISTORY\s*\n(.*?)^\s*\#\s*END\s+HISTORY[^\S\n]*\n/\# START HISTORY\n# autogenerated by $FindBin::Script\n$released_string\# END HISTORY\n/sm;
                $file_props->{version_changed} = 1;
                $file_props->{version} = $release_props->{release};
            } elsif ($file =~ m!^t/(.*\.t)\z!) {
                my $name = $1;
                $file_props->{content} =~ s/^((?:\#.*\n)*\#.*it should work as )[`']perl\s+(t\/|).*[`']\s*\n/$1`perl $2$name'\n/;
            } elsif ($file eq "Makefile.PL") {
                require FindBin;
                $file_props->{content} =~ s{^[^\S\n]*\#\s*START\s+MY\s*\n(.*?)^\s*\#\s*END\s+MY[^\S\n]*\n}{# START MY
# autogenerated by $FindBin::Script
package MY;
sub postamble {
    return shift->SUPER::postamble() . <<"EOF";
ppm: \\\$(DISTNAME).ppd

\\\$(DISTNAME).ppd: all ppd
	makeppd.pl "--perl=\\\$(PERL)" --min_version=1.013 "--zip=\\\$(ZIP)" "--tar=\\\$(TAR)" "--compress=\\\$(COMPRESS)" --leave=ppm \\\$(DISTNAME).ppd \\\$(VERSION)

cover:
	cover -delete
	-HARNESS_PERL_SWITCHES=-MDevel::Cover make test
	cover

ppm_install: \\\$(DISTNAME).ppd
	ppm install ppm/\\\$(DISTNAME).ppd

ppm_uninstall:
	ppm uninstall \\\$(DISTNAME)
EOF
}
# END MY\n}sm;

            }

            $file_props->{content} =~ s/^(\s*(?:(?:my|our|BEGIN\s*\{)\s*)?\$VERSION\s*=\s*)($quot)[\d._]+\2(\s*[;\}])/$1$2$file_props->{version}$2$3/mg;

            # Did we change ?
            my $content_chksum = chksum($file_props);
            if ($file_props->{content_chksum} ne $content_chksum) {
                $file_props->{content_chksum} = $content_chksum;
                print STDERR "Updated $file\n";
            }
            my $force_package_version =
                $file =~ /\.pm\z/ &&
                $file_props->{content} =~ /\bXSLoader\b|\bDynaLoader\b/ &&
                $file_props->{version} ne $release_props->{release};
            if (!$file_props->{old_chksum} ||
                $file_props->{old_chksum} ne $file_props->{content_chksum} ||
                $force_package_version) {
                $release_props->{any_changes} = $changes = 1 if
                    !$release_props->{any_changes};
                if (!$file_props->{version_changed} || $force_package_version) {
                    $release_props->next_release;
                    $file_props->{version} = $force_package_version ?
                        $release_props->{release} :
                        $release_props->next_version($file_props->{version});
                    $file_props->{version_changed} = 1;
                    $changes++;
                }
            }
            $release_props->{released}{$file}{$file_props->{version}} ||= $release_props->{release} if $release_props->{release_changed};
        }
    } while $changes;
}

sub set_version_file {
    my ($release_props) = @_;
    die "Assertion: No RELEASE\n" if !defined $release_props->{release};

    my ($sec, $min, $hour, $mday, $mon, $year) =
        gmtime($release_props->{time_stamp});
    my $content =
        sprintf("# Generated on %4d-%02d-%02d %02d:%02d:%02d UT using $0\n",
                $year+1900, $mon+1, $mday, $hour, $min, $sec);
    $content .= "BEGIN\n";
    $content .= "DIGITS $release_props->{digits}\n";
    $content .= "RELEASE $release_props->{release}\n";

    my $file_props = $release_props->{file_props};
    # Same order as files in MANIFEST
    for my $file (@{$release_props->{files}}) {
        my $file_props = $file_props->{$file} ||
            die "Assertion: No data for $file";
        if ($file_props->{content_chksum} ne $file_props->{disk_chksum}) {
            spew($file, $file_props->{content});
            print STDERR "Restored $file\n" if $file_props->{old_chksum} && $file_props->{old_chksum} eq $file_props->{content_chksum};
        }
        $content .=
            sprintf("VERSION %s %s %s\n", @$file_props{qw(content_chksum version file)});
    }
    my $released = $release_props->{released};
    for my $file (sort keys %$released) {
        my $versions = $released->{$file};
        for my $version (sort { $b <=> $a } keys %$versions) {
            # $content .= sprintf("RELEASED $release_props->{format} $release_props->{format} %s\n", $version, $versions->{$version}, $file);
            $content .= sprintf("RELEASED %s %s %s\n",
                                $version, $versions->{$version}, $file);
        }
    }
    $content .= "END\n";
    my $c1 = $content;
    $c1 =~ s/^[^\n\S]*\#.*\n//mg;
    my $c2 = $release_props->{old_content};
    $c2 =~ s/^[^\n\S]*\#.*\n//mg;
    my $updates = 0;
    if ($c1 ne $c2) {
        if ($release_props->{old_content} eq "") {
            print STDERR "New $sums\n";
        } else {
            print STDERR "Updated $sums\n";
            spew("$sums.old", $release_props->{old_content})
        }
        spew($sums, $content);
        $updates++;
    }
    return $updates;
}

package main;
eval {
    my $release_props = PackageTools::Release->get_versions_file;
    $release_props->get_files;
    $release_props->release;
    $release_props->set_version_file;
};
die "Aborted: $@" if $@;
